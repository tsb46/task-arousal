"""
Shared dataset loading utilities used by subject-level loaders across datasets.
"""
from typing import Any

import numpy as np
import pandas as pd
import nibabel as nib 

from nilearn.masking import apply_mask, unmask 
from scipy.stats import zscore 


def load_physio(fp: str, normalize: bool = False) -> pd.DataFrame:
    """
    Load a preprocessed physio table. Currently supports TSV.GZ files.

    Parameters
    ----------
    fp : str
        Path to the physio file. Expected to be a gzipped TSV when coming from
        the pipelines in this repository.
    normalize : bool
        Z-score each numeric column across time.

    Returns
    -------
    pd.DataFrame
    """
    # Prefer TSV.GZ generated by our preprocessing; other formats can be added later.
    if fp.endswith('.tsv.gz'):
        df = pd.read_csv(fp, sep='\t', compression='gzip')
    elif fp.endswith('.tsv'):
        df = pd.read_csv(fp, sep='\t')
    else:
        # Fallback: try generic whitespace-delimited; this can be extended for HCP raw logs.
        df = pd.read_csv(fp, sep=r'\s+', header=None)

    if normalize and not df.empty:
        df = df.apply(zscore, axis=0)  # type: ignore
    return df


def load_fmri(
    fp: str,
    mask_img: Any,
    normalize: bool = False,
    convert_to_2d: bool = True,
    verbose: bool = False,
) -> np.ndarray | nib.nifti1.Nifti1Image:
    """
    Load an fMRI NIfTI and optionally mask to 2D (time x voxels) with per-voxel z-scoring.

    Parameters
    ----------
    fp : str
        NIfTI file path.
    mask_img : nib.Nifti1Image
        Brain mask in the same space as fp.
    normalize : bool
        If convert_to_2d, z-score each voxel across time (axis=0 after masking).
    convert_to_2d : bool
        If False, return nib.Nifti1Image unchanged.

    Returns
    -------
    np.ndarray | nib.Nifti1Image
        2D array (time x voxels) if convert_to_2d else the 4D image.
    """
    img = nib.nifti1.load(fp)
    if not isinstance(img, nib.nifti1.Nifti1Image):
            raise ValueError("Expected Nifti1Image")
    
    if not convert_to_2d:
        return img

    data_2d = apply_mask(img, mask_img)  # shape: time x voxels
    if normalize:
        data_2d = zscore(data_2d, axis=0)
        # convert to numpy array for NaN checking
        data_2d = np.array(data_2d)
        # calculate if any NaNs are present after z-scoring
        voxels_nan = np.isnan(data_2d).any(axis=0)
        if voxels_nan.any():
            # calculate number of voxels with NaNs
            n_voxels_nan = np.sum(voxels_nan)
            # print warning
            if verbose:
                print(f"Warning: {n_voxels_nan} voxels have NaN values after z-scoring for file: {fp}")
            # replace NaNs with zeros
            data_2d[:, voxels_nan] = 0.0

    return data_2d


def to_4d(fmri_2d: np.ndarray, mask_img: nib.nifti1.Nifti1Image) -> nib.nifti1.Nifti1Image:
    """
    Unmask a 2D fMRI array (time x voxels) back to a 4D NIfTI using the provided mask.
    """
    fmri_4d_img = unmask(fmri_2d, mask_img)
    assert isinstance(fmri_4d_img, nib.nifti1.Nifti1Image), "to_4d did not return a Nifti1Image."
    return fmri_4d_img
